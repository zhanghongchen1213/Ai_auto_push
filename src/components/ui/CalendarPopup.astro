---
interface Props {
	currentDate: string;
	availableDates: string[];
}

const { currentDate, availableDates } = Astro.props;

const basePath = import.meta.env.BASE_URL.replace(/\/$/, '');
---

<div
	class="calendar-popup-wrapper"
	data-current-date={currentDate}
	data-available-dates={JSON.stringify(availableDates)}
	data-base-path={basePath}
>
	<!-- Desktop overlay (click to close) -->
	<div class="calendar-overlay" aria-hidden="true"></div>

	<!-- Mobile backdrop -->
	<div class="calendar-backdrop" aria-hidden="true"></div>

	<!-- Calendar dialog -->
	<div
		class="calendar-dialog"
		role="dialog"
		aria-modal="true"
		aria-label="选择日期"
	>
		<!-- Mobile drag handle -->
		<div class="calendar-drag-handle" aria-hidden="true">
			<div class="drag-bar"></div>
		</div>

		<!-- Month navigation header -->
		<div class="calendar-header">
			<button
				class="month-nav-btn month-prev"
				type="button"
				aria-label="上一个月"
			>
				<svg viewBox="0 0 20 20" fill="none" aria-hidden="true" width="16" height="16">
					<path d="M12.5 15L7.5 10L12.5 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
				</svg>
			</button>
			<span class="month-display" aria-live="polite"></span>
			<button
				class="month-nav-btn month-next"
				type="button"
				aria-label="下一个月"
			>
				<svg viewBox="0 0 20 20" fill="none" aria-hidden="true" width="16" height="16">
					<path d="M7.5 5L12.5 10L7.5 15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
				</svg>
			</button>
		</div>

		<!-- Weekday headers -->
		<div class="calendar-weekdays" role="row" aria-hidden="true">
			<span>日</span><span>一</span><span>二</span><span>三</span><span>四</span><span>五</span><span>六</span>
		</div>

		<!-- Date grid (populated by JS) -->
		<div class="calendar-grid" role="grid" aria-label="日期选择"></div>
	</div>
</div>

<script>
class CalendarPopup {
	private wrapper: HTMLElement;
	private dialog: HTMLElement;
	private overlay: HTMLElement;
	private backdrop: HTMLElement;
	private grid: HTMLElement;
	private monthDisplay: HTMLElement;
	private triggerBtn: HTMLElement | null = null;

	private currentDate: string;
	private availableDatesSet: Set<string>;
	private basePath: string;
	private viewYear: number;
	private viewMonth: number; // 0-indexed
	private isOpen = false;

	// Bound handler references for proper cleanup
	private boundEscapeHandler: (e: KeyboardEvent) => void;

	constructor(wrapper: HTMLElement) {
		this.wrapper = wrapper;

		// Safe DOM queries with fallback validation
		const dialog = wrapper.querySelector<HTMLElement>('.calendar-dialog');
		const overlay = wrapper.querySelector<HTMLElement>('.calendar-overlay');
		const backdrop = wrapper.querySelector<HTMLElement>('.calendar-backdrop');
		const grid = wrapper.querySelector<HTMLElement>('.calendar-grid');
		const monthDisplay = wrapper.querySelector<HTMLElement>('.month-display');

		if (!dialog || !overlay || !backdrop || !grid || !monthDisplay) {
			throw new Error('CalendarPopup: missing required child elements');
		}

		this.dialog = dialog;
		this.overlay = overlay;
		this.backdrop = backdrop;
		this.grid = grid;
		this.monthDisplay = monthDisplay;

		this.currentDate = wrapper.dataset.currentDate ?? '';
		this.basePath = wrapper.dataset.basePath ?? '';

		// Safe JSON parse with fallback
		let rawDates: string[] = [];
		try {
			rawDates = JSON.parse(wrapper.dataset.availableDates ?? '[]');
			if (!Array.isArray(rawDates)) rawDates = [];
		} catch {
			console.warn('CalendarPopup: failed to parse availableDates, using empty array');
			rawDates = [];
		}
		this.availableDatesSet = new Set(rawDates);

		// Initialize view to current date's month
		const [y, m] = this.currentDate.split('-').map(Number);
		this.viewYear = y;
		this.viewMonth = m - 1;

		// Store bound handler for cleanup
		this.boundEscapeHandler = (e: KeyboardEvent) => {
			if (e.key === 'Escape' && this.isOpen) {
				e.preventDefault();
				this.close();
			}
		};

		this.bindEvents();
		this.render();
	}

	private bindEvents(): void {
		// Month navigation
		this.wrapper.querySelector('.month-prev')!.addEventListener('click', () => {
			this.changeMonth(-1);
		});
		this.wrapper.querySelector('.month-next')!.addEventListener('click', () => {
			this.changeMonth(1);
		});

		// Close on overlay/backdrop click
		this.overlay.addEventListener('click', () => this.close());
		this.backdrop.addEventListener('click', () => this.close());

		// Close on Escape (using stored reference for cleanup)
		document.addEventListener('keydown', this.boundEscapeHandler);

		// Date cell clicks (delegated)
		this.grid.addEventListener('click', (e: Event) => {
			const target = e.target as HTMLElement;
			const cell = target.closest('[data-date]') as HTMLElement | null;
			if (!cell || cell.getAttribute('aria-disabled') === 'true') return;
			const date = cell.dataset.date!;
			window.location.href = `${this.basePath}/daily/${date}/`;
		});

		// Keyboard navigation in grid
		this.grid.addEventListener('keydown', (e: KeyboardEvent) => {
			this.handleGridKeydown(e);
		});
	}

	private handleGridKeydown(e: KeyboardEvent): void {
		const focused = document.activeElement as HTMLElement;
		if (!focused?.dataset.date) return;

		const cells = Array.from(this.grid.querySelectorAll<HTMLElement>('[data-date]'));
		const idx = cells.indexOf(focused);
		if (idx === -1) return;

		let nextIdx = idx;
		switch (e.key) {
			case 'ArrowRight': nextIdx = idx + 1; break;
			case 'ArrowLeft': nextIdx = idx - 1; break;
			case 'ArrowDown': nextIdx = idx + 7; break;
			case 'ArrowUp': nextIdx = idx - 7; break;
			case 'Enter':
			case ' ':
				if (focused.getAttribute('aria-disabled') !== 'true') {
					e.preventDefault();
					focused.click();
				}
				return;
			default: return;
		}

		e.preventDefault();
		if (nextIdx >= 0 && nextIdx < cells.length) {
			cells[nextIdx].focus();
		}
	}

	open(trigger: HTMLElement): void {
		this.triggerBtn = trigger;
		this.isOpen = true;
		this.wrapper.classList.add('is-open');
		trigger.setAttribute('aria-expanded', 'true');

		// Focus trap: focus first available date or first cell
		requestAnimationFrame(() => {
			const firstFocusable = this.grid.querySelector<HTMLElement>(
				'[data-date]:not([aria-disabled="true"])'
			);
			firstFocusable?.focus();
		});

		// Trap focus within dialog
		document.addEventListener('keydown', this.trapFocus);
	}

	close(): void {
		this.isOpen = false;
		this.wrapper.classList.remove('is-open');
		this.triggerBtn?.setAttribute('aria-expanded', 'false');
		this.triggerBtn?.focus();
		document.removeEventListener('keydown', this.trapFocus);
	}

	/** Remove all global listeners to prevent memory leaks */
	destroy(): void {
		document.removeEventListener('keydown', this.boundEscapeHandler);
		document.removeEventListener('keydown', this.trapFocus);
	}

	toggle(trigger: HTMLElement): void {
		if (this.isOpen) {
			this.close();
		} else {
			this.open(trigger);
		}
	}

	private trapFocus = (e: KeyboardEvent): void => {
		if (e.key !== 'Tab') return;
		const focusable = this.dialog.querySelectorAll<HTMLElement>(
			'button, [tabindex]:not([tabindex="-1"])'
		);
		if (focusable.length === 0) return;

		const first = focusable[0];
		const last = focusable[focusable.length - 1];

		if (e.shiftKey && document.activeElement === first) {
			e.preventDefault();
			last.focus();
		} else if (!e.shiftKey && document.activeElement === last) {
			e.preventDefault();
			first.focus();
		}
	};

	private changeMonth(delta: number): void {
		this.viewMonth += delta;
		if (this.viewMonth > 11) {
			this.viewMonth = 0;
			this.viewYear++;
		} else if (this.viewMonth < 0) {
			this.viewMonth = 11;
			this.viewYear--;
		}
		this.render();
	}

	private createCell(day: number, classes: string[], attrs: Record<string, string>): HTMLSpanElement {
		const cell = document.createElement('span');
		cell.className = classes.join(' ');
		cell.textContent = String(day);
		for (const [key, value] of Object.entries(attrs)) {
			cell.setAttribute(key, value);
		}
		return cell;
	}

	private render(): void {
		this.monthDisplay.textContent = `${this.viewYear}年${this.viewMonth + 1}月`;

		const today = new Date();
		const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

		// First day of month and total days
		const firstDay = new Date(this.viewYear, this.viewMonth, 1).getDay();
		const daysInMonth = new Date(this.viewYear, this.viewMonth + 1, 0).getDate();
		const daysInPrevMonth = new Date(this.viewYear, this.viewMonth, 0).getDate();

		const fragment = document.createDocumentFragment();

		// Previous month trailing days
		for (let i = firstDay - 1; i >= 0; i--) {
			const day = daysInPrevMonth - i;
			fragment.appendChild(this.createCell(day, ['calendar-cell', 'calendar-cell--outside'], {
				role: 'gridcell', 'aria-disabled': 'true', tabindex: '-1',
			}));
		}

		// Current month days
		for (let day = 1; day <= daysInMonth; day++) {
			const dateStr = `${this.viewYear}-${String(this.viewMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
			const hasData = this.availableDatesSet.has(dateStr);
			const isSelected = dateStr === this.currentDate;
			const isToday = dateStr === todayStr;

			const classes = ['calendar-cell'];
			if (isSelected) classes.push('calendar-cell--selected');
			else if (isToday) classes.push('calendar-cell--today');
			if (hasData && !isSelected) classes.push('calendar-cell--available');
			if (!hasData) classes.push('calendar-cell--disabled');

			const disabled = !hasData;
			const label = `${this.viewYear}年${this.viewMonth + 1}月${day}日${isToday ? '（今天）' : ''}${hasData ? '' : '（无数据）'}`;

			fragment.appendChild(this.createCell(day, classes, {
				role: 'gridcell',
				'data-date': dateStr,
				'aria-disabled': String(disabled),
				'aria-label': label,
				tabindex: String(disabled ? -1 : 0),
			}));
		}

		// Next month leading days
		const totalCells = firstDay + daysInMonth;
		const remaining = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
		for (let i = 1; i <= remaining; i++) {
			fragment.appendChild(this.createCell(i, ['calendar-cell', 'calendar-cell--outside'], {
				role: 'gridcell', 'aria-disabled': 'true', tabindex: '-1',
			}));
		}

		this.grid.replaceChildren(fragment);
	}
}

// Initialize all calendar popups on the page
document.querySelectorAll<HTMLElement>('.calendar-popup-wrapper').forEach((el) => {
	const instance = new CalendarPopup(el);
	// Expose toggle method for the trigger button
	(el as any).__calendarPopup = instance;
});
</script>

<style>
	/* Wrapper: hidden by default */
	.calendar-popup-wrapper {
		position: relative;
		display: none;
	}
	.calendar-popup-wrapper.is-open {
		display: block;
	}

	/* Desktop overlay (transparent, catches outside clicks) */
	.calendar-overlay {
		display: none;
	}

	/* Mobile backdrop */
	.calendar-backdrop {
		display: none;
	}

	/* Calendar dialog - desktop: dropdown */
	.calendar-dialog {
		position: absolute;
		top: 4px;
		left: 50%;
		transform: translateX(-50%) translateY(-8px);
		width: 280px;
		background: #fff;
		border-radius: 8px;
		box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
		padding: 16px;
		z-index: 100;
		opacity: 0;
		pointer-events: none;
		transition: opacity 0.2s ease-out, transform 0.2s ease-out;
	}
	.is-open .calendar-dialog {
		opacity: 1;
		transform: translateX(-50%) translateY(0);
		pointer-events: auto;
	}

	/* Desktop overlay - fixed fullscreen to catch outside clicks */
	.is-open .calendar-overlay {
		display: block;
		position: fixed;
		inset: 0;
		z-index: 99;
	}

	/* Drag handle: hidden on desktop */
	.calendar-drag-handle {
		display: none;
	}

	/* Month header */
	.calendar-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		margin-bottom: 12px;
	}
	.month-display {
		font-size: 16px;
		font-weight: 600;
		color: #1a1a1a;
	}
	.month-nav-btn {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		width: 28px;
		height: 28px;
		border: none;
		border-radius: 6px;
		background: transparent;
		color: #595959;
		cursor: pointer;
		transition: background-color 0.15s, color 0.15s;
	}
	.month-nav-btn:hover {
		background: #f0f5ff;
		color: #1677ff;
	}
	.month-nav-btn:focus-visible {
		outline: 2px solid #1677ff;
		outline-offset: 2px;
	}

	/* Weekday headers */
	.calendar-weekdays {
		display: grid;
		grid-template-columns: repeat(7, 1fr);
		text-align: center;
		margin-bottom: 4px;
	}
	.calendar-weekdays span {
		font-size: 12px;
		font-weight: 400;
		color: #8c8c8c;
		padding: 4px 0;
	}

	/* Date grid */
	.calendar-grid {
		display: grid;
		grid-template-columns: repeat(7, 1fr);
		gap: 2px;
		text-align: center;
	}

	/* Calendar cells - base */
	.calendar-grid :global(.calendar-cell) {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		width: 36px;
		height: 36px;
		margin: 0 auto;
		font-size: 14px;
		font-weight: 400;
		border-radius: 50%;
		cursor: default;
		position: relative;
		transition: background-color 0.15s, color 0.15s;
	}

	/* Available (has data) */
	.calendar-grid :global(.calendar-cell--available) {
		color: #1a1a1a;
		cursor: pointer;
	}
	.calendar-grid :global(.calendar-cell--available:hover) {
		background: #f0f5ff;
		color: #1677ff;
	}
	.calendar-grid :global(.calendar-cell--available:focus-visible) {
		outline: 2px solid #1677ff;
		outline-offset: 2px;
	}

	/* Selected (current date) */
	.calendar-grid :global(.calendar-cell--selected) {
		background: #1677ff;
		color: #fff;
		font-weight: 600;
		cursor: pointer;
	}

	/* Today (not selected) */
	.calendar-grid :global(.calendar-cell--today) {
		color: #1677ff;
		font-weight: 600;
	}
	.calendar-grid :global(.calendar-cell--today::after) {
		content: '';
		position: absolute;
		bottom: 2px;
		left: 50%;
		transform: translateX(-50%);
		width: 4px;
		height: 4px;
		border-radius: 50%;
		background: #1677ff;
	}

	/* Disabled (no data) */
	.calendar-grid :global(.calendar-cell--disabled) {
		color: #d9d9d9;
	}

	/* Outside current month */
	.calendar-grid :global(.calendar-cell--outside) {
		color: #e8e8e8;
	}

	/* ===== Mobile: bottom sheet ===== */
	@media (max-width: 767px) {
		.is-open .calendar-backdrop {
			display: block;
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.4);
			z-index: 99;
		}

		.is-open .calendar-overlay {
			display: none;
		}

		.calendar-dialog {
			position: fixed;
			top: auto;
			bottom: 0;
			left: 0;
			right: 0;
			width: 100%;
			max-width: 100%;
			border-radius: 16px 16px 0 0;
			transform: translateX(0) translateY(100%);
			padding: 12px 16px calc(16px + env(safe-area-inset-bottom));
			z-index: 100;
		}
		.is-open .calendar-dialog {
			transform: translateX(0) translateY(0);
			transition: transform 0.3s ease-out, opacity 0.3s ease-out;
		}

		.calendar-drag-handle {
			display: flex;
			justify-content: center;
			padding: 8px 0 12px;
		}
		.drag-bar {
			width: 40px;
			height: 4px;
			border-radius: 2px;
			background: #d9d9d9;
		}

		.calendar-grid :global(.calendar-cell) {
			width: 44px;
			height: 44px;
		}
	}
</style>
